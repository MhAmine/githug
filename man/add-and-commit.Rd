% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/git_add-commit.R
\name{add-and-commit}
\alias{add-and-commit}
\alias{git_ADD}
\alias{git_COMMIT}
\alias{git_add}
\alias{git_commit}
\title{Stage and commit files}
\usage{
git_add(path, repo = ".", ...)

git_commit(message = NULL, repo = ".", ...)

git_ADD(repo = ".")

git_COMMIT(message = NULL, repo = ".")
}
\arguments{
\item{path}{Character vector with file names or shell glob
patterns that will matched against files in the repository's
working directory. Each file that matches will be added to the
index (either updating an existing entry or adding a new entry).}

\item{repo}{Path to a Git repo. If unspecified, current working directory is
checked to see if it is or is inside a Git repo.}

\item{...}{Additional arguments to \code{\link[git2r]{add}} or
\code{\link[git2r]{commit}} from \code{\link{git2r}}}

\item{message}{The commit message.}
}
\value{
Path to the associated Git repo.
}
\description{
Stage files in preparation for a commit. And then commit them. Maybe even all
at once! Convenience wrappers around \code{\link[git2r]{add}},
\code{\link[git2r]{commit}}, and \code{\link[git2r]{status}} from
\code{\link{git2r}}.
}
\details{
\code{git_add} adds the current content of files identified via
 \code{path} to the index, using \code{\link[git2r]{add}} from
 \code{\link{git2r}}. These files are slated for inclusion in the next
 commit. What might go in \code{...}? You could set `force = TRUE` if you
 want to force add ignored files.

\code{git_commit} stores the current contents of the index in a new
  commit along with a message describing the changes. What might go in
  \code{...}? Read up on the arguments to \code{\link[git2r]{commit}} from
  \code{\link{git2r}}, which this wraps.

\code{git_ADD} says "JUST STAGE ALL THE THINGS." Use this when you
  want the next commit to reflect all new files, file deletions, and file
  modifications in your repo. Similar to the automatic staging behavior of
  \href{https://git-scm.com/book/en/v2/Git-in-Other-Environments-Graphical-Interfaces}{workflow-oriented
   Git clients} like \href{https://desktop.github.com}{GitHub Desktop}. The
  intent is to emulate \code{git add -A}, which is equivalent to \code{git
  add .; git add -u}.

\code{git_COMMIT} says "JUST COMMIT ALL THE THINGS." Use this when
  you just want to commit the current state of your repo. It is
  \code{git_ADD} followed by \code{git_commit}. The intent is to emulate
  \code{git add -A && git commit}.
}
\examples{
## conventional git add, status, commit
repo <- git_init(tempfile("githug-"))
owd <- setwd(repo)
writeLines("Are these girls real smart or real real lucky?", "max.txt")
git_add("max.txt")
git_status()
git_commit("Brains'll only get you so far and luck always runs out.")
git_status()
setwd(owd)

if (require(dplyr)) {
  ## are pipes silly here? perhaps ...
  repo <- tempfile("githug-") \%>\%
    git_init()
  owd <- setwd(repo)
  writeLines("Are these girls real smart or real real lucky?", "max.txt")
  "max.txt" \%>\%
    git_add() \%>\%
    git_status()
  git_commit("Brains'll only get you so far and luck always runs out.") \%>\%
    git_status()
  setwd(owd)
}

## THE SHOUTY COMMANDS
repo <- git_init(tempfile("GITHUG-"))
owd <- setwd(repo)
writeLines("Change me", "change-me")
writeLines("Delete me", "delete-me")
git_status()
git_add(c("change-me", "delete-me"))
git_status()
git_commit("initial")
write("OK", "change-me", append = TRUE)
file.remove("delete-me")
writeLines("Add me", "add-me")
git_status()
git_ADD()
git_status()
## TO DO: return here when commits and reset are wrapped
ccc <- git2r::commits()[[1]]
git2r::reset(ccc, "mixed")
git_status()
git_COMMIT("JUST DO IT.")
git_status()
setwd(owd)
}

